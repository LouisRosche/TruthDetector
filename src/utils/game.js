/**
 * GAME UTILITIES
 * Game-specific helper functions for claims, roles, and player display
 */

import { CLAIMS_DATABASE } from '../data/claims';
import { TEAM_ROLES, SUBJECT_HINTS } from '../data/constants';
import { shuffleArray } from './generic';

/**
 * Select claims based on difficulty and optional subject filter
 * GUARANTEES no duplicate claims within a session
 * @param {string} difficulty - 'easy' | 'medium' | 'hard' | 'mixed'
 * @param {number} count - Number of claims to select
 * @param {Array<string>} subjects - Optional array of subjects to include (empty = all)
 * @returns {Array} Selected claims (unique, no repeats)
 */
export function selectClaimsByDifficulty(difficulty, count, subjects = []) {
  // Filter by subjects if specified
  let pool = CLAIMS_DATABASE;
  if (subjects && subjects.length > 0) {
    pool = CLAIMS_DATABASE.filter(c => subjects.includes(c.subject));
  }

  // Track used claim IDs to prevent any duplicates
  const usedIds = new Set();
  const selectedClaims = [];

  const selectUnique = (sourcePool, maxCount) => {
    const shuffled = shuffleArray([...sourcePool]);
    const result = [];
    for (const claim of shuffled) {
      if (result.length >= maxCount) break;
      if (!usedIds.has(claim.id)) {
        usedIds.add(claim.id);
        result.push(claim);
      }
    }
    return result;
  };

  if (difficulty === 'mixed') {
    // Progressive: distribute claims across difficulties
    const easyCount = Math.ceil(count * 0.3);
    const medCount = Math.ceil(count * 0.4);
    const hardCount = count - easyCount - medCount;

    const easyPool = pool.filter(c => c.difficulty === 'easy');
    const medPool = pool.filter(c => c.difficulty === 'medium');
    const hardPool = pool.filter(c => c.difficulty === 'hard');

    const easy = selectUnique(easyPool, easyCount);
    const med = selectUnique(medPool, medCount);
    const hard = selectUnique(hardPool, hardCount);

    // Order: easy first, then medium, then hard
    selectedClaims.push(...easy, ...med, ...hard);

    // If we didn't get enough claims, fill from remaining pool
    if (selectedClaims.length < count) {
      const remaining = pool.filter(c => !usedIds.has(c.id));
      const additional = selectUnique(remaining, count - selectedClaims.length);
      selectedClaims.push(...additional);
    }
  } else {
    // Single difficulty mode
    const filtered = pool.filter(c => c.difficulty === difficulty);
    const selected = selectUnique(filtered, count);
    selectedClaims.push(...selected);

    // If we didn't get enough claims of this difficulty, fill from others
    if (selectedClaims.length < count) {
      const remaining = pool.filter(c => !usedIds.has(c.id));
      const additional = selectUnique(remaining, count - selectedClaims.length);
      selectedClaims.push(...additional);
    }
  }

  // Final safety check: ensure absolutely no duplicates
  const uniqueClaims = [];
  const seenIds = new Set();
  for (const claim of selectedClaims) {
    if (!seenIds.has(claim.id)) {
      seenIds.add(claim.id);
      uniqueClaims.push(claim);
    }
  }

  return uniqueClaims.slice(0, count);
}

/**
 * Get rotating team role assignments based on round
 * @param {number} round - Current round number
 * @returns {Array} Roles in order for this round
 */
export function getRotatingRoles(round) {
  const rotation = (round - 1) % TEAM_ROLES.length;
  return [...TEAM_ROLES.slice(rotation), ...TEAM_ROLES.slice(0, rotation)];
}

/**
 * Format player display name
 * @param {string} firstName - First name
 * @param {string} lastInitial - Last initial
 * @returns {string} Formatted name (e.g., "John D.")
 */
export function formatPlayerName(firstName, lastInitial) {
  const cleanFirst = (firstName || '').trim();
  const cleanLast = (lastInitial || '').trim().charAt(0).toUpperCase();
  if (!cleanFirst) return 'Anonymous';
  return cleanLast ? `${cleanFirst} ${cleanLast}.` : cleanFirst;
}

/**
 * Get hint content for a claim
 * @param {Object} claim - The claim object
 * @param {string} hintType - Type of hint requested
 * @returns {string} Hint content
 */
export function getHintContent(claim, hintType) {
  switch(hintType) {
    case 'source-hint':
      return claim.source === 'ai-generated'
        ? 'ðŸ¤– This claim was generated by AI'
        : 'ðŸ“š This claim comes from expert sources';
    case 'error-hint':
      if (claim.source === 'expert-sourced') {
        return "âœ… This claim doesn't contain typical AI errors";
      }
      return `ðŸŽ¯ Look for: ${claim.errorPattern}`;
    case 'subject-hint':
      return SUBJECT_HINTS[claim.subject] || 'Think critically about this subject area!';
    default:
      return 'No hint available.';
  }
}
