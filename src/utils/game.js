/**
 * GAME UTILITIES
 * Game-specific helper functions for claims, roles, and player display
 */

import { CLAIMS_DATABASE } from '../data/claims';
import { TEAM_ROLES, SUBJECT_HINTS } from '../data/constants';
import { shuffleArray } from './generic';

/**
 * Select claims based on difficulty and optional subject filter
 * @param {string} difficulty - 'easy' | 'medium' | 'hard' | 'mixed'
 * @param {number} count - Number of claims to select
 * @param {Array<string>} subjects - Optional array of subjects to include (empty = all)
 * @returns {Array} Selected claims
 */
export function selectClaimsByDifficulty(difficulty, count, subjects = []) {
  // Filter by subjects if specified
  let pool = CLAIMS_DATABASE;
  if (subjects && subjects.length > 0) {
    pool = CLAIMS_DATABASE.filter(c => subjects.includes(c.subject));
  }

  if (difficulty === 'mixed') {
    // Progressive: distribute claims across difficulties
    const easyCount = Math.ceil(count * 0.3);
    const medCount = Math.ceil(count * 0.4);
    const hardCount = count - easyCount - medCount;

    const easy = shuffleArray(pool.filter(c => c.difficulty === 'easy')).slice(0, easyCount);
    const med = shuffleArray(pool.filter(c => c.difficulty === 'medium')).slice(0, medCount);
    const hard = shuffleArray(pool.filter(c => c.difficulty === 'hard')).slice(0, hardCount);

    // Order: easy first, then medium, then hard
    return [...easy, ...med, ...hard];
  }

  const filtered = pool.filter(c => c.difficulty === difficulty);
  return shuffleArray(filtered).slice(0, count);
}

/**
 * Get rotating team role assignments based on round
 * @param {number} round - Current round number
 * @returns {Array} Roles in order for this round
 */
export function getRotatingRoles(round) {
  const rotation = (round - 1) % TEAM_ROLES.length;
  return [...TEAM_ROLES.slice(rotation), ...TEAM_ROLES.slice(0, rotation)];
}

/**
 * Format player display name
 * @param {string} firstName - First name
 * @param {string} lastInitial - Last initial
 * @returns {string} Formatted name (e.g., "John D.")
 */
export function formatPlayerName(firstName, lastInitial) {
  const cleanFirst = (firstName || '').trim();
  const cleanLast = (lastInitial || '').trim().charAt(0).toUpperCase();
  if (!cleanFirst) return 'Anonymous';
  return cleanLast ? `${cleanFirst} ${cleanLast}.` : cleanFirst;
}

/**
 * Get hint content for a claim
 * @param {Object} claim - The claim object
 * @param {string} hintType - Type of hint requested
 * @returns {string} Hint content
 */
export function getHintContent(claim, hintType) {
  switch(hintType) {
    case 'source-hint':
      return claim.source === 'ai-generated'
        ? 'ðŸ¤– This claim was generated by AI'
        : 'ðŸ“š This claim comes from expert sources';
    case 'error-hint':
      if (claim.source === 'expert-sourced') {
        return "âœ… This claim doesn't contain typical AI errors";
      }
      return `ðŸŽ¯ Look for: ${claim.errorPattern}`;
    case 'subject-hint':
      return SUBJECT_HINTS[claim.subject] || 'Think critically about this subject area!';
    default:
      return 'No hint available.';
  }
}
